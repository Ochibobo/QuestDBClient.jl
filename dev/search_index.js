var documenterSearchIndex = {"docs":
[{"location":"man/functional/#Functional-Approach","page":"Functional Approach","title":"Functional Approach","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"The QuestDBClient can be used with functions to write data to a QuestDB server instance.","category":"page"},{"location":"man/functional/#API","page":"Functional Approach","title":"API","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"The API that describes the implementation this functional approach can be found here:","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"Pages = [\"../lib/operators.md\"]","category":"page"},{"location":"man/functional/#Example","page":"Functional Approach","title":"Example","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"note: Note\nThe functions need to following order:     table -> symbol -> others -> At/AtNowothers represent field types such as integers, floats etc. The terminal symbol for each chain should be At() or AtNow(). Not following the specified order will result in an exception being thrown.","category":"page"},{"location":"man/functional/#Basic-Example","page":"Functional Approach","title":"Basic Example","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"using QuestDBClient\n\n\"\"\"\nAssumes the presence of a table called readings created using:\n\nCREATE TABLE readings (\n  timestamp TIMESTAMP,\n  city SYMBOL,\n  temperature DOUBLE,\n  humidity DOUBLE,\n  make SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY;\n\"\"\"\n\n## Create a sender instance that will connect to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Create ILP records\nsender |>\n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Omron) |>\n    x -> symbol(x, :city => :Nairobi) |>\n    x -> FloatColumn(x, :tempareture => 26.8) |> \n    x -> FloatColumn(x, :humidity => 0.51) |>\n    x -> AtNow(x)\n\nsender |> \n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Honeywell) |> \n    x -> symbol(x, :city => :London) |>\n    x -> FloatColumn(x, :tempareture => 22.9) |> \n    x -> FloatColumn(x, :humidity => 0.254) |>\n    x -> AtNow(x)\n\nsender |> \n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Omron) |> \n    x -> symbol(x, :city => :Bristol) |>\n    x -> FloatColumn(x, :tempareture => 23.9) |> \n    x -> FloatColumn(x, :humidity => 0.233) |>\n    x -> AtNow(x)\n    \n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/functional/#Working-with-DataFrames","page":"Functional Approach","title":"Working with DataFrames","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"DataFrames can also be used as a datasource in the QuestDBClient. However, some preprocessing is needed such as converting/casting the column types to supported types. The table also needs to be specified beforehand, the column that represents the designated timestamp and any symbols(tags) need to be specified too.","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"Supported types include: Symbol, Integer and subtypes, AbstractFloat and subtypes, Bool, Char, AbstractString and subtypes,         Date, DateTime, UUID.","category":"page"},{"location":"man/functional/#Example-2","page":"Functional Approach","title":"Example","text":"","category":"section"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"note: Note\nThis example requires the installation of the DataFrames.jl package.","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"A DataFrame object with the following structure will be used in the example:","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"city make tempareture humidity\nLondon Omron 29.4 0.334\nNairobi Honeywell 24.0 0.51","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"using DataFrames\nusing QuestDBClient\n\n## Create a DataFrame instance\ndf = DataFrame(city=[\"London\", \"Nairobi\"], \n               make=[:Omron, :Honeywell], \n               temperature=[29.4, 24.0], \n               humidity=[0.334, 0.51])\n\n## Create a sender instance that will connect to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Map the dataframe data to ILP record statements\nsender |> x -> Source(x, df, :readings, symbols=[:city, :make])\n## can also use: Source(sender, df, :readings, symbols=[:city, :make]);\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"An example with the At field specified.","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"city make tempareture humidity collection_time\nLondon Omron 29.4 0.334 2023-04-10T13:09:31Z\nNairobi Honeywell 24.0 0.51 2023-04-10T13:09:42Z","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"using DataFrames\nusing Dates\nusing QuestDBClient\n\n## A DataFrame instance\ndf = DataFrame(city=[\"London\", \"Nairobi\"], \n               make=[:Omron, :Honeywell], \n               temperature=[29.4, 24.0], \n               humidity=[0.334, 0.51], \n               collection_time=[\"2023-04-10T13:09:31Z\", \"2023-04-10T13:09:42Z\"])\n\n## Cast the collection_time to DateTime\ndate_format = dateformat\"y-m-dTH:M:SZ\"\ndf[!, :collection_time] = DateTime.(df[:, :collection_time], date_format)\n\n## Create a sender instance that will connect to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Map the dataframe data to ILP record statements\nsender |> x -> Source(x, df, :readings, symbols = [:city, :make], at = :collection_time)\n## can also use: Source(sender, df, :readings, symbols = [:city, :make], at = :collection_time)\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/functional/","page":"Functional Approach","title":"Functional Approach","text":"note: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded while reading the rows of the  DataFrame. This is even before the flush or close function is called.","category":"page"},{"location":"man/macros/#Macro-Approach","page":"Macro Approach","title":"Macro Approach","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"The QuestDBClient can be used with macros to write data to a QuestDB server instance.","category":"page"},{"location":"man/macros/#API","page":"Macro Approach","title":"API","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"The API that describes the implementation this macro-based approach can be found here:","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"Pages = [\"../lib/types.md\"]","category":"page"},{"location":"man/macros/#Example","page":"Macro Approach","title":"Example","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"note: Note\nThe functions need to following order:     table -> symbol -> others -> At/AtNowothers represent field types such as integers, floats etc. The terminal symbol for each chain should be @At() or @AtNow(). Not following the specified order will result in an exception being thrown.","category":"page"},{"location":"man/macros/#Basic-Example","page":"Macro Approach","title":"Basic Example","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"using QuestDBClient\n\n\"\"\"\nAssumes the presence of a table called readings created using:\n\nCREATE TABLE readings (\n  timestamp TIMESTAMP,\n  city SYMBOL,\n  temperature DOUBLE,\n  humidity DOUBLE,\n  make SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY;\n\"\"\"\n\n## Connects to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Create ILP record statements\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :Omron) |>\n    @symbol(:city => :Lisbon) |>\n    @FloatColumn(:tempareture => 24.8) |>\n    @FloatColumn(:humidity => 0.334) |>\n    @AtNow\n\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :HoneyWell) |>\n    @symbol(:city => :Kisumu) |>\n    @FloatColumn(:tempareture => 30.2) |>\n    @FloatColumn(:humidity => 0.54) |>\n    @AtNow\n\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :Omron) |>\n    @symbol(:city => :Berlin) |>\n    @FloatColumn(:tempareture => 26.1) |>\n    @FloatColumn(:humidity => 0.45) |>\n    @AtNow\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/macros/#Working-with-DataFrames","page":"Macro Approach","title":"Working with DataFrames","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"DataFrames can also be used as a datasource in the QuestDBClient. However, some preprocessing is needed such as converting/casting the column types to supported types. The table also needs to be specified beforehand, the column that represents the designated timestamp and any symbols(tags) need to be specified too.","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"Supported types include: Symbol, Integer and subtypes, AbstractFloat and subtypes, Bool, Char, AbstractString and subtypes,         Date, DateTime, UUID.","category":"page"},{"location":"man/macros/#Example-2","page":"Macro Approach","title":"Example","text":"","category":"section"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"note: Note\nThis example requires the installation of the DataFrames.jl package.","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"A DataFrame object with the following structure will be used in the example:","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"city make tempareture humidity\nLondon Omron 29.4 0.334\nNairobi Honeywell 24.0 0.51","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"using DataFrames\nusing QuestDBClient\n\n## Create a DataFrame instance\ndf = DataFrame(city=[\"London\", \"Nairobi\"], \n               make=[:Omron, :Honeywell], \n               temperature=[29.4, 24.0], \n               humidity=[0.334, 0.51])\n\n## Create a sender instance that will connect to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Map the dataframe data to ILP record statements\nsender |> @source(df = df, table = :readings, symbols=[:city, :make])\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"An example with the At field specified.","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"city make tempareture humidity collection_time\nLondon Omron 29.4 0.334 2023-04-10T13:09:31Z\nNairobi Honeywell 24.0 0.51 2023-04-10T13:09:42Z","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"using DataFrames\nusing Dates\nusing QuestDBClient\n\n## A DataFrame instance\ndf = DataFrame(city=[\"London\", \"Nairobi\"], \n               make=[:Omron, :Honeywell], \n               temperature=[29.4, 24.0], \n               humidity=[0.334, 0.51], \n               collection_time=[\"2023-04-10T13:09:31Z\", \"2023-04-10T13:09:42Z\"])\n\n## Cast the collection_time to DateTime\ndate_format = dateformat\"y-m-dTH:M:SZ\"\ndf[!, :collection_time] = DateTime.(df[:, :collection_time], date_format)\n\n## Create a sender instance that will connect to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Map the dataframe data to ILP record statements\nsender |> @source(df = df, table = :readings, symbols = [:city, :make], at = :collection_time)\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"man/macros/","page":"Macro Approach","title":"Macro Approach","text":"note: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded while reading the rows of the  DataFrame. This is even before the flush or close function is called.","category":"page"},{"location":"lib/sender/#QuestDBSender","page":"Sender","title":"QuestDBSender","text":"","category":"section"},{"location":"lib/sender/","page":"Sender","title":"Sender","text":"Documentation for QuestDBSender","category":"page"},{"location":"lib/sender/","page":"Sender","title":"Sender","text":"CurrentModule = QuestDBClient.QuestDBSender","category":"page"},{"location":"lib/sender/","page":"Sender","title":"Sender","text":"Pages = [\"sender.md\"]\nModules = [QuestDBSender]","category":"page"},{"location":"lib/sender/","page":"Sender","title":"Sender","text":"QuestDBSender.DEFAULT_BUFFER_SIZE\nAuth\nSender\nQuestDBSender.write(sender::Sender)\nQuestDBSender.clear(sender::Sender)\nQuestDBSender.connect(sender::Sender)\nQuestDBSender.flush(sender::Sender)\nQuestDBSender.close(sender::Sender)","category":"page"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.DEFAULT_BUFFER_SIZE","page":"Sender","title":"QuestDBClient.QuestDBSender.DEFAULT_BUFFER_SIZE","text":"const DEFAULT_BUFFER_SIZE::Int = 128 * 1024\n\nDefault buffer size of the sender's buffer\n\n\n\n\n\n","category":"constant"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.Auth","page":"Sender","title":"QuestDBClient.QuestDBSender.Auth","text":"See: https://questdb.io/docs/reference/api/ilp/authenticate\n\nAuthentication object used\n\n\n\n\n\n","category":"type"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.Sender","page":"Sender","title":"QuestDBClient.QuestDBSender.Sender","text":"@with_kw mutable struct Sender\n    host::String=\"127.0.0.1\"\n    port::Int=9009\n    batchSize::Int=DEFAULT_BUFFER_SIZE\n    tlsMode::Bool=false\n    hasTable::Bool=false\n    hasFields::Bool=false\n    auth::Union{Auth, Nothing} = nothing ## Can be changed into a new \n    buffer::String = \"\"\n    socket::Union{TCPSocket, Nothing} = nothing\nend\n\nSender struct is the entity responsible for connecting to the QuestDB Server, build records & send them using the ILP protocol. \n\nArguments\n\nhost::String - the host address. The default one is the localhost or 127.0.0.1\nport::Int - the port connected to on the host machine. Default value is 9009\nbatchSize::Int - the buffer size beyond which the contents of the buffer written to the server. Default size is 128 * 1024\nhasTable::Bool - used to indicate if an ILP record statement has a table defined\nhasFields::Bool - used to indicate if an ILP record statement has fields defined\nbuffer::String - used to buffer ILP record statements before writing them to the server\nsocket::Union{TCPSocket, Nothing} - holds the socket connection to the QuestDB Server instance\n\n\n\n\n\n","category":"type"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.write-Tuple{Sender}","page":"Sender","title":"QuestDBClient.QuestDBSender.write","text":"write(sender::Sender)\n\nAttempts to write the ILP record statements to the server. In case of an error, an exception is thrown\n\n\n\n\n\n","category":"method"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.clear-Tuple{Sender}","page":"Sender","title":"QuestDBClient.QuestDBSender.clear","text":"clear(sender::Sender)\n\nClears the buffer contents\n\n\n\n\n\n","category":"method"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.connect-Tuple{Sender}","page":"Sender","title":"QuestDBClient.QuestDBSender.connect","text":"connect(sender::Sender)\n\nAttempts to connect the sender to the server socket. In case of an error, an exception is thrown\n\n\n\n\n\n","category":"method"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.flush-Tuple{Sender}","page":"Sender","title":"QuestDBClient.QuestDBSender.flush","text":"flush(sender::Sender)\n\nAttempts to flush any unsent text to the server socket. In case of an error, an exception is thrown\n\n\n\n\n\n","category":"method"},{"location":"lib/sender/#QuestDBClient.QuestDBSender.close-Tuple{Sender}","page":"Sender","title":"QuestDBClient.QuestDBSender.close","text":"close(sender::Sender)\n\nAttempts to close the sender's connection to the server. In case of an error, an exception is thrown\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#QuestDBTypes","page":"Types","title":"QuestDBTypes","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"CurrentModule = QuestDBClient.QuestDBTypes","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]\nModules = [QuestDBTypes]","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"QuestDBTypes.@table\nQuestDBTypes.@symbol\nQuestDBTypes.@IntegerColumn\nQuestDBTypes.@BoolColumn\nQuestDBTypes.@FloatColumn\nQuestDBTypes.@StringColumn\nQuestDBTypes.@CharColumn\nQuestDBTypes.@DateTimeColumn\nQuestDBTypes.@DateColumn\nQuestDBTypes.@UUIDColumn\nQuestDBTypes.@At\nQuestDBTypes.@AtNow\nQuestDBTypes.@source","category":"page"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@table","page":"Types","title":"QuestDBClient.QuestDBTypes.@table","text":"@table(name)\n\n@table definition macro for an ILP entry. Returns an expression that upon evaluation returns a closure that taken a sender as an argument.  Once the closure is evaluated, it adds a table name to the sender's buffer and returns the sender with an updated buffer.\n\nThe name should be of type ColumnName\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> sender |> @table(:readings)\n## sender with table readings\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@symbol","page":"Types","title":"QuestDBClient.QuestDBTypes.@symbol","text":"@symbol(symbol::Pair{T, V}) where {T <: ColumnName, V <: SymbolColumnValue}\n\n@symbol definition macro for an ILP entry. Adds a symbol (tag_set) to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, it adds a symbol to the sender's buffer and returns the sender with an updated buffer. The symbol argument is a Pair{T, V} where T <: ColumnName and V <: SymbolColumnValue\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nThe SymbolColumnValue is Union{Symbol, String}\n\nExample\n\njulia> sender |> @symbol(:make => :Omron)\n## sender with symbol make=Omron\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@IntegerColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@IntegerColumn","text":"@IntegerColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{Integer, Nothing}}\n\n@IntegerColumn definition macro for an ILP entry. Adds a field of type integer to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, it returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Integer, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nThe SymbolColumnValue is Union{Symbol, String}\n\nAll Integer subtypes are supported:     Bool, BigInt, Int128, Int64, Int32, Int16, Int8,     UInt128, UInt64, UInt32, UInt16, UInt8\n\nExample\n\njulia> sender |> @IntegerColumn(:count => 12)\n## sender with field count=12\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @IntegerColumn(:count => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@BoolColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@BoolColumn","text":"BoolColumn(sender::Sender, data::Pair{T, Bool}) where {T <: ColumnName}\n\n@BoolColumn definition macro for an ILP entry. Adds a field of type bool to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer.  The data argument is a Pair{T, Bool} where T <: ColumnName.\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> sender |> @BoolColumn(:present => true)\n## sender with field present=true\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@FloatColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@FloatColumn","text":"@FloatColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{AbstractFloat, Nothing}}\n\n@FloatColumn definition function for an ILP entry. Adds a field of type float to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer. \n\nThe data argument is a Pair{T, V} where T <: ColumnName and V <: Union{AbstractFloat, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nAll AbstractFloat subtypes are supported:     BigFloat, Float64, Float32, Float16\n\nExample\n\njulia> sender |> @FloatColumn(:tempareture => 29.4)\n## sender with field tempareture=29.4\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @FloatColumn(:tempareture => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@StringColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@StringColumn","text":"@StringColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{AbstractString, Nothing}}\n\n@StringColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer. \n\nThe data argument is a Pair{T, V} where T <: ColumnName and V <: Union{AbstractString, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nAll AbstractString subtypes are supported:     Core.Compiler.LazyString, InlineStrings.InlineString, LaTeXStrings.LaTeXString, LazyString,     String, SubString, SubstitutionString, Test.GenericString\n\nExample\n\njulia> sender |> @StringColumn(:city => \"Nairobi\")\n## sender with field city=Nairobi\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @StringColumn(:city => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@CharColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@CharColumn","text":"@CharColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{Char, Nothing}}\n\n@CharColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer. \n\nThe data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Char, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> sender |> @CharColumn(:region => 'A')\n## sender with field region=A\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @CharColumn(:region => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@DateTimeColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@DateTimeColumn","text":"@DateTimeColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{DateTime, Nothing}}\n\n@DateTimeColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer.  The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{DateTime, Nothing}\n\nThe DateTime is converted to milliseconds since UNIXEPOCH\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> sender |> @DateTimeColumn(:pick_up_date => now())\n## sender with field pick_up_date=1680990219992\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @DateTimeColumn(:pick_up_date => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@DateColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@DateColumn","text":"@DateColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{Date, Nothing}}\n\n@DateColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer.  The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Date, Nothing}\n\nThe Date is converted to milliseconds since UNIXEPOCH\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> sender |> @DateColumn(:collection_date => Date(2023, 4, 8))\n## sender with field collection_date=1680912000000\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @DateColumn(:collection_date => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@UUIDColumn","page":"Types","title":"QuestDBClient.QuestDBTypes.@UUIDColumn","text":"@UUIDColumn(data::Pair{T, V}) where {T <: ColumnName, V <: Union{UUID, String, Nothing}}\n\n@UUIDColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer.  The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{UUID, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> using UUIDs\njulia> using Random\njulia> rng = MersenneTwister(1234);\njulia> u4 = uuid4(rng);\njulia> sender |> @UUIDColumn(:user_id => u4)\n## sender with field user_id=7a052949-c101-4ca3-9a7e-43a2532b2fa8\n\nWorks too when the passed UUID is a string\n\nExample\n\njulia> sender |> @UUIDColumn(:user_id => \"7a052949-c101-4ca3-9a7e-43a2532b2fa8\")\n## sender with field user_id=7a052949-c101-4ca3-9a7e-43a2532b2fa8\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> sender |> @UUIDColumn(:user_id => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@At","page":"Types","title":"QuestDBClient.QuestDBTypes.@At","text":"@At(timestamp::DateTime)\n\n@At column definition function for an ILP entry. This is the designated timestamp field.\n\nThe timestamp is converted to nanoseconds since UNIXEPOCH. \n\nIt returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer. \n\nThis requires that a table has already been added to the sender's buffer.\n\nUpon setting this field, the hasFields and hasTable properties of the sender are set to false. This also marks the  end of the record with a '\\n'. Furthermore, the sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded.\n\nServes as a terminal definition of a record. Should always be defined last.\n\nExample\n\njulia> sender |> At(now())\n## sender with field 1680993284179000000\\n\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@AtNow","page":"Types","title":"QuestDBClient.QuestDBTypes.@AtNow","text":"@AtNow\n\nThis requires that a table has already been added to the sender's buffer.\n\nResolves to:     @At(now())\n\nExample\n\njulia> sender |> AtNow\n## sender with field 1680993284179000000\\n\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#QuestDBClient.QuestDBTypes.@source","page":"Types","title":"QuestDBClient.QuestDBTypes.@source","text":"@source(df::DataFrame = DataFrame(), table::TT = \"\",  at::T = \"\", \n        symbols::Vector{V} = []) where {TT<: ColumnName, T <: ColumnName, V <: ColumnName}\n\nTakes in a DataFrame object and creates ILP insert statement for each row element.\n\nThis macro requires named arguments to be specified:\n\nArguments\n\ndf::DataFrame: the DataFrame that serves as the source of the data\ntable::TT where {TT <: ColumnName} : the name of the table\nat::T where {T <: ColumnName} : the column that has timestamp values that server as the designated timestamp\nsymbols::Vector{V} where {V <: ColumnName}: the list of column names whose columns serve as tag_set values for an ILP record\n\nThe ColumnName is Union{Symbol, String}\n\nnote: Note\nOnly the df and table parameters must be specified. Then at and symbols parameters are optional.\n\nIt returns the closure that takes a sender as an argument. Once the closure is evaluated, returns the sender with an updated buffer.\n\nThe table specification is a requirement.\n\nnote: Note\nSupported column data types include:     Symbol, Integer and subtypes, AbstractFloat and subtypes, Bool, Char, AbstractString and subtypes,     Date, DateTime, UUIDFor DataFrames, entries of type Missing are not supported. They should be cast to Nothing.\n\nat argument is used to specify the column header of the column in the DataFrame that will serve as the designated timestamp field. The column should have values of type DateTime and will be converted to nanoseconds upon when converted to an ILP record. If the at is not specified, the current time will be added to each ILP record.\n\nsymbols argument specifies a vector of columns headers of DataFrame columns that serve as the tag_set in the ILP statement. If symbols are not specified, then no tag_set fields will be part of the ILP statement.\n\ncity make tempareture humidity\nLondon Omron 29.4 0.334\nNairobi Honeywell 24.0 0.51\n\nAssuming df below is the DataFrame above:\n\nExample\n\njulia> using DataFrames\njulia> df = DataFrame(city=[\"London\", \"Nairobi\"], make=[:Omron, :Honeywell], temperature=[29.4, 24.0], humidity=[0.334, 0.51]);\njulia> sender |> source(df = df, table = :readings, symbols=[:city, :make]);\n## sender with 2 ILP records from the 2 rows in the DataFrame\n\ncity make tempareture humidity collection_time\nLondon Omron 29.4 0.334 2023-04-10T13:09:31Z\nNairobi Honeywell 24.0 0.51 2023-04-10T13:09:42Z\n\nAn example with the at field specified.\n\nExample\n\njulia> using DataFrames\njulia> df = DataFrame(city=[\"London\", \"Nairobi\"], make=[:Omron, :Honeywell], temperature=[29.4, 24.0], \n            humidity=[0.334, 0.51], collection_time=[\"2023-04-10T13:09:31Z\", \"2023-04-10T13:09:42Z\"]);\njulia> using Dates\njulia> date_format = dateformat\"y-m-dTH:M:SZ\";\njulia> df[!, :collection_time] = DateTime.(df[:, :collection_time], date_format);\njulia> sender |> @source(df = df, table = :readings, symbols = [:city, :make], at = :collection_time);\n## sender with 2 ILP records from the 2 rows in the DataFrame\n\nnote: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded while reading the rows of the  DataFrame. This is even before the flush or close function is called.\n\n\n\n\n\n","category":"macro"},{"location":"#QuestDBClient.jl","page":"Home","title":"QuestDBClient.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QuestDBClient.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QuestDBClient","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a Julia package that can be used to connect to a QuestDB database server and send data using the InfluxDB Line Protocol. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is strictly used to write data to the database. Reading is not supported. To read data from QuestDB, you can use QuestDB's LibPQ or DBInterface through port 8812. Alternatively, you can read the data over through QuestDB's REST API on port 9000. Visit QuestDB's docs to get more information on how to query data. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nYou can join the QuestDB Community here.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install the package at the Pkg REPL-mode with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(@v1.8) pkg> add QuestDBClient","category":"page"},{"location":"#Quick-Examples","page":"Home","title":"Quick Examples","text":"","category":"section"},{"location":"#Functional-Approach","page":"Home","title":"Functional Approach","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using functions to write to a QuestDB Server:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuestDBClient\n\n\"\"\"\nAssumes the presence of a table called readings created using:\n\nCREATE TABLE readings (\n  timestamp TIMESTAMP,\n  city SYMBOL,\n  temperature DOUBLE,\n  humidity DOUBLE,\n  make SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY;\n\"\"\"\n\n## Connects to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Create ILP records\nsender |>\n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Omron) |>\n    x -> symbol(x, :city => :Nairobi) |>\n    x -> FloatColumn(x, :tempareture => 26.8) |> \n    x -> FloatColumn(x, :humidity => 0.51) |>\n    x -> AtNow(x)\n\nsender |> \n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Honeywell) |> \n    x -> symbol(x, :city => :London) |>\n    x -> FloatColumn(x, :tempareture => 22.9) |> \n    x -> FloatColumn(x, :humidity => 0.254) |>\n    x -> AtNow(x)\n\nsender |> \n    x -> table(x, :readings) |> \n    x -> symbol(x, :make => :Omron) |> \n    x -> symbol(x, :city => :Bristol) |>\n    x -> FloatColumn(x, :tempareture => 23.9) |> \n    x -> FloatColumn(x, :humidity => 0.233) |>\n    x -> AtNow(x)\n    \n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nYou can use packages such as Chain.jl, Pipe.jl, Lazy.jl or any other for function chaining, based on your preference.","category":"page"},{"location":"#Macro-based-approach","page":"Home","title":"Macro based approach","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using macros to write to the QuestDB Server:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using QuestDBClient\n\n\"\"\"\nAssumes the presence of a table called readings created using:\n\nCREATE TABLE readings (\n  timestamp TIMESTAMP,\n  city SYMBOL,\n  temperature DOUBLE,\n  humidity DOUBLE,\n  make SYMBOL\n) TIMESTAMP(timestamp) PARTITION BY DAY;\n\"\"\"\n\n## Connects to the localhost at port 9009\nsender = Sender()\n\n## Connect the sender to the server first\nconnect(sender)\n\n## Create ILP record statements\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :Omron) |>\n    @symbol(:city => :Lisbon) |>\n    @FloatColumn(:tempareture => 24.8) |>\n    @FloatColumn(:humidity => 0.334) |>\n    @AtNow\n\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :HoneyWell) |>\n    @symbol(:city => :Kisumu) |>\n    @FloatColumn(:tempareture => 30.2) |>\n    @FloatColumn(:humidity => 0.54) |>\n    @AtNow\n\nsender |>\n    @table(:readings) |>\n    @symbol(:make => :Omron) |>\n    @symbol(:city => :Berlin) |>\n    @FloatColumn(:tempareture => 26.1) |>\n    @FloatColumn(:humidity => 0.45) |>\n    @AtNow\n\n## Flush the output to the server\nQuestDBSender.flush(sender)\n\n## Close the socket connection\n## Close first calls QuestDBSender.flush(sender) as part of its definition\nQuestDBSender.close(sender)","category":"page"},{"location":"#Package-Manual","page":"Home","title":"Package Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"man/functional.md\",\n    \"man/macros.md\",\n    \"man/dataframes.md\"\n]","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This client exposes a set of endpoints. However, some need to be prefixed with a module name because of the naming collision with existing Base functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/sender.md\",\n    \"lib/operators.md\",\n    \"lib/types.md\"\n]","category":"page"},{"location":"lib/exceptions/#QuestDBExceptions","page":"Exceptions","title":"QuestDBExceptions","text":"","category":"section"},{"location":"lib/exceptions/","page":"Exceptions","title":"Exceptions","text":"CurrentModule = QuestDBClient.QuestDBExceptions","category":"page"},{"location":"lib/exceptions/","page":"Exceptions","title":"Exceptions","text":"Pages = [\"exceptions.md\"]\nModules = [QuestDBExceptions]","category":"page"},{"location":"lib/exceptions/","page":"Exceptions","title":"Exceptions","text":"QuestDBClientException\nIllegalTableNameCharacterException\nIllegalColumnNameCharacterException\nEmptyColumnNameException\nColumnNameLengthLimitExceededException\nMultipleTableDefinitionsException\nMissingTableDeclarationException\nMalformedLineProtocolSyntaxException\nUnsupportedColumnTypeException\nUnsupportedAtColumnTypeException","category":"page"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.QuestDBClientException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.QuestDBClientException","text":"abstract type QuestDBClientException <: Exception end\n\nCustom exception type used in QuestDBClient\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.IllegalTableNameCharacterException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.IllegalTableNameCharacterException","text":"struct IllegalTableNameCharacterException <: QuestDBClientException\n    errorMessage::String\nend\n\nIllegal Table Name character exception\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.IllegalColumnNameCharacterException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.IllegalColumnNameCharacterException","text":"struct IllegalColumnNameCharacterException <: QuestDBClientException\n    errorMessage::String\nend\n\nIllegal Column Name character exception\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.EmptyColumnNameException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.EmptyColumnNameException","text":"struct EmptyColumnNameException <: QuestDBClientException\n    errorMessage::String\nend\n\nEmpty Column Name exception\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.ColumnNameLengthLimitExceededException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.ColumnNameLengthLimitExceededException","text":"struct ColumnNameLengthLimitExceededException <: QuestDBClientException\n    message::String\nend\n\nColumn Name Length LimitnExceeded exception\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.MultipleTableDefinitionsException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.MultipleTableDefinitionsException","text":"struct MultipleTableDefinitionsException <: QuestDBClientException\n    message::String\nend\n\nMultiple Table definitions detected\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.MissingTableDeclarationException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.MissingTableDeclarationException","text":"struct MissingTableDeclarationException <: QuestDBClientException\n    message::String\nend\n\nMissing table declaration detected -> May change this to MalformedLineProtocolSyntaxException\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.MalformedLineProtocolSyntaxException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.MalformedLineProtocolSyntaxException","text":"struct MalformedLineProtocolSyntaxException <: QuestDBClientException\n    message::String\nend\n\nMalformed Line Protocol syntax detected\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.UnsupportedColumnTypeException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.UnsupportedColumnTypeException","text":"struct UnsupportedColumnTypeException <: QuestDBClientException\n    message::String\nend\n\nUnsupported Column Types detected\n\n\n\n\n\n","category":"type"},{"location":"lib/exceptions/#QuestDBClient.QuestDBExceptions.UnsupportedAtColumnTypeException","page":"Exceptions","title":"QuestDBClient.QuestDBExceptions.UnsupportedAtColumnTypeException","text":"struct UnsupportedAtColumnTypeException <: QuestDBClientException\n    message::String\nend\n\nSpecified At Column is not a timestamp\n\n\n\n\n\n","category":"type"},{"location":"lib/operators/#QuestDBOperators","page":"Operators","title":"QuestDBOperators","text":"","category":"section"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"CurrentModule = QuestDBClient.QuestDBOperators","category":"page"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"Pages = [\"operators.md\"]\nModules = [QuestDBOperators]","category":"page"},{"location":"lib/operators/","page":"Operators","title":"Operators","text":"ColumnName\nSymbolColumnValue\nsupportedTypes\nCOMMA\nSPACE_CHARACTER\nRETURN_CHARACTER\nEQUALS_CHARACTER\nUNSUPPORTED_CHARACTERS\nQuestDBOperators.table\nQuestDBOperators.symbol\nQuestDBOperators.writeSymbol\nQuestDBOperators.IntegerColumn\nQuestDBOperators.writeFieldColumn\nQuestDBOperators.checkUnsupportedCharacters\nQuestDBOperators.BoolColumn\nQuestDBOperators.FloatColumn\nQuestDBOperators.StringColumn\nQuestDBOperators.CharColumn\nQuestDBOperators.DateTimeColumn\nQuestDBOperators.DateColumn\nQuestDBOperators.UUIDColumn\nQuestDBOperators.At\nQuestDBOperators.AtNow\nQuestDBOperators.Source\nQuestDBOperators.writeRowEnty!","category":"page"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.ColumnName","page":"Operators","title":"QuestDBClient.QuestDBOperators.ColumnName","text":"const ColumnName = Union{Symbol, String}\n\nThe column name can be specified as a symbol or as a string\n\n\n\n\n\n","category":"type"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.SymbolColumnValue","page":"Operators","title":"QuestDBClient.QuestDBOperators.SymbolColumnValue","text":"const SymbolColumnValue = Union{Symbol, String}\n\nA symbol column can take values that are either a Symbol or a String\n\n\n\n\n\n","category":"type"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.supportedTypes","page":"Operators","title":"QuestDBClient.QuestDBOperators.supportedTypes","text":"const supportedTypes::Vector{Type} = [Integer, AbstractFloat, AbstractString, Symbol, Dates.DateTime, \n                                     Dates.Date, Char, UUID]\n\nA list of supported types\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.COMMA","page":"Operators","title":"QuestDBClient.QuestDBOperators.COMMA","text":"const COMMA = \",\"\n\nA constant referencing a comma - ','\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.SPACE_CHARACTER","page":"Operators","title":"QuestDBClient.QuestDBOperators.SPACE_CHARACTER","text":"const SPACE_CHARACTER = ' '\n\nA constant referencing the space character\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.RETURN_CHARACTER","page":"Operators","title":"QuestDBClient.QuestDBOperators.RETURN_CHARACTER","text":"const RETURN_CHARACTER = '\\n'\n\nA constant referencing the return character\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.EQUALS_CHARACTER","page":"Operators","title":"QuestDBClient.QuestDBOperators.EQUALS_CHARACTER","text":"const EQUALS_CHARACTER = '='\n\nA constant referencing the equals character.\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.UNSUPPORTED_CHARACTERS","page":"Operators","title":"QuestDBClient.QuestDBOperators.UNSUPPORTED_CHARACTERS","text":"const UNSUPPORTED_CHARACTERS = ['?', '.' , ',' , ''' , '\"' , '\\' , '/', ':' , '(' , ')' , '+' , '-' , '*' , '%' , '~' , ' ' , '\u0000']\n\nThe list of unsupported characters for table & column names\n\n\n\n\n\n","category":"constant"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.table","page":"Operators","title":"QuestDBClient.QuestDBOperators.table","text":"table(sender::Sender, name::T)::Sender where {T <: ColumnName}\n\nTable definition function for an ILP entry. Adds a table name to the sender's buffer and returns the sender with an updated buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> table(sender, :readings)\n## sender with table readings\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.symbol","page":"Operators","title":"QuestDBClient.QuestDBOperators.symbol","text":"symbol(sender::Sender, symbol::Pair{T, V})::Sender where {T <: ColumnName, V <: SymbolColumnValue}\n\nSymbol definition function for an ILP entry. Adds a symbol (tag_set) to the sender's buffer and returns the sender with an updated buffer. The symbol argument is a Pair{T, V} where T <: ColumnName and V <: SymbolColumnValue\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nThe SymbolColumnValue is Union{Symbol, String}\n\nExample\n\njulia> symbol(sender, :make => :Omron)\n## sender with symbol make=Omron\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.writeSymbol","page":"Operators","title":"QuestDBClient.QuestDBOperators.writeSymbol","text":"writeSymbol(queryString::String, symbol::Pair{T, V})::String where {T <: ColumnName, V <: SymbolColumnValue}\n\nFunction used to create append a symbol when constructing an ILP string.  The symbol argument is a Pair{T, V} where T <: ColumnName and V <: SymbolColumnValue\n\nAlso asserts that QuestDB unsupported column name characters result in exception propagation\n\nThe ColumnName is Union{Symbol, String}\n\nThe SymbolColumnValue is Union{Symbol, String}\n\nExample\n\njulia> writeSymbol(\"\", :make => :Omron)\nmake=Omron \n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.IntegerColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.IntegerColumn","text":"IntegerColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{Integer, Nothing}}\n\nIntegerColumn definition function for an ILP entry. Adds a field of type integer to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Integer, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nAll Integer subtypes are supported:     Bool, BigInt, Int128, Int64, Int32, Int16, Int8,     UInt128, UInt64, UInt32, UInt16, UInt8\n\nExample\n\njulia> IntegerColumn(sender, :count => 12)\n## sender with field count=12\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> IntegerColumn(sender, :count => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.writeFieldColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.writeFieldColumn","text":"writeFieldColumn(queryString::String, data::Pair{T, V})::String where {T <:ColumnName, V <: Any}\n\nFunction used to append any other field to the ILP entry. If the type of V is nothing, the passed field will not be written to the queryString which is eventually appended to the sender's buffer.\n\nA check for unsupported column characters is also performed.\n\nExample\n\njulia> writeFieldColumn(sender, :count => 15)\n## sender with field count=12\n\nExample\n\njulia> IntegerColumn(sender, :count => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.checkUnsupportedCharacters","page":"Operators","title":"QuestDBClient.QuestDBOperators.checkUnsupportedCharacters","text":"checkUnsupportedCharacters(subject::T, exception::Type{E}) where {T <: ColumnName, E <: QuestDBClientException}\n\nAsserts that only supported column name characters pass this evaluation. Any unsupported character results in throwing a QuestDBClientException.\n\nUnsupported characters include:     ['?', '.' , ',' , ''' , '\"' , '\\' , '/', ':' , '(' , ')' , '+' , '-' , '*' , '%' , '~' , ' ' , '\u0000']\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.BoolColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.BoolColumn","text":"BoolColumn(sender::Sender, data::Pair{T, Bool})::Sender where {T <: ColumnName}\n\nBoolColumn definition function for an ILP entry. Adds a field of type bool to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, Bool} where T <: ColumnName.\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> BoolColumn(sender, :present => true)\n## sender with field present=true\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.FloatColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.FloatColumn","text":"FloatColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{AbstractFloat, Nothing}}\n\nFloatColumn definition function for an ILP entry. Adds a field of type float to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{AbstractFloat, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nAll AbstractFloat subtypes are supported:     BigFloat, Float64, Float32, Float16\n\nExample\n\njulia> FloatColumn(sender, :tempareture => 29.4)\n## sender with field tempareture=29.4\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> FloatColumn(sender, :tempareture => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.StringColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.StringColumn","text":"StringColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{AbstractString, Nothing}}\n\nStringColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{AbstractString, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nAll AbstractString subtypes are supported:     Core.Compiler.LazyString, InlineStrings.InlineString, LaTeXStrings.LaTeXString, LazyString,     String, SubString, SubstitutionString, Test.GenericString\n\nExample\n\njulia> StringColumn(sender, :city => \"Nairobi\")\n## sender with field city=Nairobi\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> StringColumn(sender, :city => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.CharColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.CharColumn","text":"CharColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{Char, Nothing}}\n\nCharColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Char, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> CharColumn(sender, :region => 'A')\n## sender with field region=A\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> CharColumn(sender, :region => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.DateTimeColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.DateTimeColumn","text":"DateTimeColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{DateTime, Nothing}}\n\nDateTimeColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{DateTime, Nothing}\n\nThe DateTime is converted to milliseconds since UNIXEPOCH\n\nThis is not the record's designated timestamp field but another field whose value is a timestamp.\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> DateTimeColumn(sender, :pick_up_date => now())\n## sender with field pick_up_date=1680990219992\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> DateTimeColumn(sender, :pick_up_date => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.DateColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.DateColumn","text":"DateColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{Date, Nothing}}\n\nDateColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{Date, Nothing}\n\nThe Date is converted to milliseconds since UNIXEPOCH\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> DateColumn(sender, :collection_date => Date(2023, 4, 8))\n## sender with field collection_date=1680912000000\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> DateColumn(sender, :collection_date => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.UUIDColumn","page":"Operators","title":"QuestDBClient.QuestDBOperators.UUIDColumn","text":"UUIDColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{UUID, Nothing}}\n\nUUIDColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{UUID, Nothing}\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> using UUIDs\njulia> using Random\njulia> rng = MersenneTwister(1234);\njulia> u4 = uuid4(rng);\njulia> UUIDColumn(sender, :user_id => u4)\n## sender with field user_id=7a052949-c101-4ca3-9a7e-43a2532b2fa8\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> UUIDColumn(sender, :user_id => nothing)\n## sender without an updated buffer\n\n\n\n\n\nUUIDColumn(sender::Sender, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Union{String, Nothing}}\n\nUUIDColumn definition function for an ILP entry. Adds a field of type string to the sender's buffer and returns the sender with an updated buffer. The data argument is a Pair{T, V} where T <: ColumnName and V <: Union{String, Nothing}\n\nTakes in the UUID as a string.\n\nThis requires that a table has already been added to the sender's buffer.\n\nThe ColumnName is Union{Symbol, String}\n\nExample\n\njulia> UUIDColumn(sender, :user_id => \"7a052949-c101-4ca3-9a7e-43a2532b2fa8\")\n## sender with field user_id=7a052949-c101-4ca3-9a7e-43a2532b2fa8\n\nIf nothing is passed as the second part of the part of the data pair, V, this column won't be written\n\nExample\n\njulia> UUIDColumn(sender, :user_id => nothing)\n## sender without an updated buffer\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.At","page":"Operators","title":"QuestDBClient.QuestDBOperators.At","text":"At(sender::Sender, timestamp::DateTime)::Nothing\n\nAt column definition function for an ILP entry. This is the designated timestamp field.\n\nThe timestamp is converted to nanoseconds since UNIXEPOCH\n\nThis requires that a table has already been added to the sender's buffer.\n\nUpon setting this field, the hasFields and hasTable properties of the sender are set to false. This also marks the  end of the record with a '\\n'.\n\nServes as a terminal definition of a record. Should always be defined last.\n\nnote: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded when At is executed.\n\nExample\n\njulia> At(sender, now())\n## sender with field 1680993284179000000\\n\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.AtNow","page":"Operators","title":"QuestDBClient.QuestDBOperators.AtNow","text":"AtNow(sender::Sender)::Nothing\n\nThis requires that a table has already been added to the sender's buffer.\n\nResolves to:     At(sender, now())\n\nnote: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded when AtNow(sender) is executed.\n\nExample\n\njulia> AtNow(sender)\n## sender with field 1680993284179000000\\n\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.Source","page":"Operators","title":"QuestDBClient.QuestDBOperators.Source","text":"Source(sender::Sender, df::DataFrame, table::TT; \n       at::T = \"\", symbols::Vector{V} = [])::Sender where {TT<: ColumnName, T <: ColumnName, V <: ColumnName}\n\nTakes in a DataFrame object and creates ILP insert statement for each row element. \n\nArguments\n\n- `sender::Sender` : QUestDBClient sender object\n- `df::DataFrame`: the `DataFrame` that serves as the source of the data\n- `table::TT where {TT <: ColumnName}` : the name of the `table`\n- `at::T where {T <: ColumnName}` : the column that has timestamp values that server as the designated timestamp\n- `symbols::Vector{V} where {V <: ColumnName}`: the list of column names whose columns serve as `tag_set` values for an ILP record\n\nnote: Note\nThe sender, df, and table arguments are compulsory and are positional arguments. The at and symbols arguments are optional named arguments.\n\nThe ColumnName is Union{Symbol, String}\n\nThe table specification is a requirement.\n\nnote: Note\nSupported column data types include:     Symbol, Integer and subtypes, AbstractFloat and subtypes, Bool, Char, AbstractString and subtypes,     Date, DateTime, UUIDFor DataFrames, entries of type Missing are not supported. They should be cast to Nothing.\n\nat argument is used to specify the column header of the column in the DataFrame that will serve as the designated timestamp field. The column should have values of type DateTime and will be converted to nanoseconds upon when converted to an ILP record. If the at is not specified, the current time will be added to each ILP record.\n\nsymbols argument specifies a vector of columns headers of DataFrame columns that serve as the tag_set in the ILP statement. If symbols are not specified, then no tag_set fields will be part of the ILP statement.\n\ncity make tempareture humidity\nLondon Omron 29.4 0.334\nNairobi Honeywell 24.0 0.51\n\nAssuming df below is the DataFrame above:\n\nExample\n\njulia> using DataFrames\njulia> df = DataFrame(city=[\"London\", \"Nairobi\"], make=[:Omron, :Honeywell], temperature=[29.4, 24.0], humidity=[0.334, 0.51]);\njulia> Source(sender, df, :readings, symbols=[:city, :make]);\n## sender with 2 ILP records from the 2 rows in the DataFrame\n\ncity make tempareture humidity collection_time\nLondon Omron 29.4 0.334 2023-04-10T13:09:31Z\nNairobi Honeywell 24.0 0.51 2023-04-10T13:09:42Z\n\nAn example with the at field specified.\n\nExample\n\njulia> using DataFrames\njulia> df = DataFrame(city=[\"London\", \"Nairobi\"], make=[:Omron, :Honeywell], temperature=[29.4, 24.0], \n            humidity=[0.334, 0.51], collection_time=[\"2023-04-10T13:09:31Z\", \"2023-04-10T13:09:42Z\"]);\njulia> using Dates\njulia> date_format = dateformat\"y-m-dTH:M:SZ\";\njulia> df[!, :collection_time] = DateTime.(df[:, :collection_time], date_format);\njulia> Source(sender, df, :readings, symbols = [:city, :make], at = :collection_time);\n## sender with 2 ILP records from the 2 rows in the DataFrame\n\nnote: Note\nThe sender attempts to write values to the QuestDB Database Server depending on whether the buffer size has been met or exceeded while reading the rows of the  DataFrame. This is even before the flush or close function is called.\n\n\n\n\n\n","category":"function"},{"location":"lib/operators/#QuestDBClient.QuestDBOperators.writeRowEnty!","page":"Operators","title":"QuestDBClient.QuestDBOperators.writeRowEnty!","text":"writeRowEnty!(sender::Sender, dataType::Type, data::Pair{T, V})::Sender where {T <: ColumnName, V <: Any}\n\nA helper function to build ILP records from a dataframe based on the column types.\n\n\n\n\n\n","category":"function"}]
}
